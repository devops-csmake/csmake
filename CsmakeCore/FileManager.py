# <copyright>
# (c) Copyright 2019, 2021 Autumn Patterson
# (c) Copyright 2021 Cardinal Peak Technologies
# (c) Copyright 2017 Hewlett Packard Enterprise Development LP
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# </copyright>
import re
import os.path
import os
import glob
import threading

# A file spec is a specification of a set of instances
#  consisting of search axes - primarily id, type, intent, and location
#    id refers to a user defined grouping of files
# A file record is all the files (and derivitives) of an id
#   - could have many types/locations
#   - a record also tracks history
#  - How do we decide what instances a record is seeded with?
#     We get a set of file specs
#     Expand the file specs
#     Add the files
#  - In a mapping if you specify an id only, you get all of the leaves
#    of the derivitives
#  - id+type yields all members of the id of the specified type
#  - type yields all members of all records of the specified type
#    if there is a mapping to a result, those results will go back
#    into the appropriate record in a 1-1 scenario or into a new
#    derived record if a new id is specified or if *-1 with multiple
#    records  id preservation is conservative as possible this
#    way you could say something simple like
#    (liba<c:source>) path/*.c -(1-1)-> (<elf-relocatable-object:linkable>) res/*.o
#    (liba) -(*-1)-> (<shared-object:library>) libs/liba.so
#    (liba), (libb), (libc) -(*-1)-> blah{version}.deb
# If you wanted to say something a little safer, you could do
#    (liba<:linkable>) -(*-1)-> (<shared-object:library>) libs/liba.so
# You could also do - where the packager module would know how to fill
#  "version" in:
#    (<:library>) -(*-1)-> blah{version}.deb
#  - Multiple mappings may be concatenated together with &&
# TODO: Need to add implementation for version

class FileMapping:
    """Represents tuples of from -> to mappings where the
       from and to are iterable objects of one or more file representations
       the "from" are stored as FileInstances and the "to" are stored
       as "spec"s which are dictionaries that fully describe a file instance"""

    def __init__(self):
        self.mappingSpecifications = set()
        self.mappings = []

    def addMappingSpecification(self, mapspec):
        self.mappingSpecifications.add(mapspec)

    def getMappingSpecification(self):
        return '+'.join(self.mappingSpecifications)

    def iterfiles(self):
        "from lists -> to lists mappings of paths/file strings"
        for mapped in self.mappings:
            fromLocations = [ inst.index['location'] for inst in mapped[0] ]
            toLocations = [ spec['location'] for spec in mapped[1] ]
            yield (fromLocations, toLocations)

    def iterspecs(self):
        """"from lists -> to lists mappings of dictionaries.  This is helpful
         if a step is interested in the type or intent of a file for example."""
        for mapped in self.mappings:
            fromSpecs = [ inst.index for inst in mapped[0] ]
            yield (fromSpecs, mapped[1])

    def itermappings(self):
        """from lists -> to lists mappings of FileInstances -> Specs.
         This is helpful to get the full FileManager context of the files
         being dealt with - for example in the case where the "to specs" are
         being integrated as real files generated by the csmake step"""
        for mapped in self.mappings:
            yield mapped

    def addMapping(self, fromInstances, toSpecs):
        self.mappings.append((fromInstances, toSpecs))

    def __len__(self):
        return len(self.mappings)

class IndexedFileEntry:
    """Base class of any index "lookup-able" file or record of files.
       This represents a protocol that anything that represents a file
       should respond to"""
    def __repr__(self, offset=0, terse=False):
        keys = list(self.index.keys())
        values = {}
        for axis in FileManager.AXES:
            if axis in self.index:
                values[axis] = self.index[axis]
                keys.remove(axis)
            else:
                values[axis] = "___"
        for nonaxis in FileManager.NON_AXES:
            if nonaxis in keys:
                keys.remove(nonaxis)
        space = " " * offset
        result = [ "%s%s:  <%s (%s:%s)> %s" % (
            space,
            self.__class__.__name__,
            values['id'],
            values['type'],
            values['intent'],
            values['relLocation'] ) ]
        result.append(" path: %s" % values['location'])
        if len(keys) > 0:
            result.append("Other Axes:")
            result.extend(["  %s: %s" % (k, self.index[k]) for k in keys])
        return '\n'.join(result)

    def __str__(self):
        return self.__repr__()

    def __init__(self):
        self.precedence = {}
        self.currentPrecedenceKey = None
        self.record = None
        self.recordid = None
        self.index = {}

    def recordId(self):
        return self.recordid

    def getRecord(self):
        return self.record

    def setRecord(self, record):
        self.record = record
        self.recordid = record.recordId()

    def getPrecedence(self, key):
        return self.precedence[key]

    def setPrecedence(self, precedence, key):
        self.precedence[key] = precedence

    def setCurrentPrecedenceKey(self, key):
        #NOTE: This has concurrency problems
        assert self.currentPrecedenceKey is None, "Possible concurrency issue"
        self.currentPrecedenceKey = key

    def finishedCurrentPrecedenceKey(self):
        assert self.currentPrecedenceKey is not None, "Possible concurrency issue"
        self.currentPrecedenceKey = None

    def __cmp__(self, other):
        if self.currentPrecedenceKey is None:
            raise ValueError("setCurrentPrecendenceKey must be called first")
        return self.getPrecedence(self.currentPrecedenceKey) \
               - other.getPrecedence(self.currentPrecedenceKey)

    def __eq__(self, other):
        if self.currentPrecedenceKey is None:
            raise ValueError("setCurrentPrecedenceKey must be called first")
        return self.getPrecedence(self.currentPrecedenceKey) \
               == other.getPrecedence(self.currentPreceedenceKey)

    def __lt__(self, other):
        if self.currentPrecedenceKey is None:
            raise ValueError("setCurrentPrecedenceKey must be called first")
        return self.getPrecedence(self.currentPrecedenceKey) \
               < other.getPrecedence(self.currentPrecedenceKey)

    def __gt__(self, other):
        if self.currentPrecedenceKey is None:
            raise ValueError("setCurrentPrecedenceKey must be called first")
        return self.getRecedence(self.currentPrecedenceKey) \
                > other.getPrecedence(self.currentPrecedenceKey)

    def __hash__(self):
        return id(self)

    def _axisMatch(self, axis, spec, specValue, instanceValue):
        if axis == 'location':
            locationre = spec.getSourceLocationRE()
            if locationre is not None:
                locationMatch = re.match(locationre,instanceValue)
                return locationMatch is not None
            else:
                return False
        elif axis == 'relLocation':

            locationre = spec.getSourceRelLocationRE()
            if locationre is not None:
                locationMatch = re.match(locationre, instanceValue)
                return locationMatch is not None
            else:
                return False
        else:
            return specValue == instanceValue

    def findInstances(self, spec):
        locationMatch = None
        for axis, value in spec.index.items():
            if axis in FileManager.NON_AXES:
                continue
            try:
                myvalue = self.index[axis]
                if type(myvalue) is str:
                    raise ValueError("Can't iterate properly on a string")
                for instanceValue in self.index[axis]:
                    if self._axisMatch(axis, spec, value, instanceValue):
                        break
                else:
                   return []
            except:
                if axis not in self.index \
                    or not self._axisMatch(
                        axis,
                        spec,
                        value,
                        self.index[axis]):
                        return []
        return self


class FileSpec(IndexedFileEntry):
    def __init__(self, **keywords):
        IndexedFileEntry.__init__(self)
        self.index = keywords
        self.locationre = None
        self.relLocationre = None
        self.resultre = None
        self.relResultre = None

    def getRESafeLocation(self):
        return self.index['location']

    def getRESafeRelLocation(self):
        return self.index['relLocation']

    def getSourceLocationRE(self):
        if self.locationre is None:
            if 'location' in self.index:
                if 'useRE' in self.index and self.index['useRE']:
                    #self.locationre = self.index['location']
                    self.locationre = self.getRESafeLocation()
                else:
                    self.locationre = FileManager.translateStarsToSourceRegex(
                        self.getRESafeLocation() )
                    #    self.index['location'] )
        return self.locationre

    def getSourceRelLocationRE(self):
        if self.relLocationre is None:
            if 'relLocation' in self.index:
                if 'useRE' in self.index and self.index['useRE']:
                    #self.relLocationre = self.index['relLocation']
                    self.relLocationre = self.getRESafeRelLocation()
                else:
                    self.relLocationre = FileManager.translateStarsToSourceRegex(
                        self.getRESafeRelLocation() )
                    #    self.index['relLocation'] )
        return self.relLocationre

    def getResultLocationRE(self):
        if self.resultre is None:
            if 'location' in self.index:
                if 'useRE' in self.index and self.index['useRE']:
                    #self.resultre = self.index['location']
                    self.resultre = self.getRESafeLocation()
                else:
                    self.resultre = FileManager.translateStarsToResultRegex(
                        self.getRESafeLocation() )
                    #    self.index['location'] )
        return self.resultre

    def getResultRelLocationRE(self):
        if self.relResultre is None:
            if 'relLocation' in self.index:
                if 'useRE' in self.index and self.index['useRE']:
                    #self.relResultre = self.index['relLocation']
                    self.relResultre = self.getRESafeRelLocation()
                else:
                    self.relResultre = FileManager.translateStarsToResultRegex(
                    #    self.index['relLocation'] )
                        self.getRESafeRelLocation() )
        return self.relResultre

    # FileSpecs and subclasses can stand in the place of a sequence
    # for convenience
    def __len__(self):
        return 1

    def __iter__(self):
        yield self

class FileInstance(FileSpec):
    def _reescape(self, s):
        return re.escape(s).replace("\/","/").replace("\.",".")

    def getRESafeLocation(self):
        return self._reescape(self.index['location'])

    def getRESafeRelLocation(self):
        return self._reescape(self.index['relLocation'])

    def __init__(self, **keywords):
        FileSpec.__init__(self, **keywords)

        if 'location' not in self.index:
            raise ValueError('A real file location must be used for a FileInstance')
        if not os.path.exists(self.index['location']):
            raise ValueError("FileInstance '%s' does not exist" % self.index['location'])

class DeletedFileInstance(FileInstance):
    def __init__(self, **keywords):
        FileSpec.__init__(self, **keywords)

        if 'location' not in self.index:
            raise ValueError("A real file location must be used for a FileInstance")
        if os.path.exists(self.index['location']):
            raise ValueError("DeletedFileInstance '%s' exists" % self.index['location'])

class NonValidatedFileInstance(FileInstance):
    def __init__(self, **keywords):
        FileSpec.__init__(self, **keywords)

class FileManager:
    """This is an unordered, searchable record container"""

    #We need to have a file manager global lock to prevent deadlocking
    #  across subclasses of filemanager.
    FILE_MANAGER_LOCK=threading.RLock()

    AXES = ['id','type','intent', 'location', 'relLocation']
    NON_AXES = ['useRE']
    FILE_AXES = ['path', 'file', 'filename', 'ext']
    FILEDECL_RE = re.compile(r"(?:\<(?P<id>[^\(\>\s]*)\s*(?:\((?P<type>[^\:\)]*)(?:\:(?P<intent>[^\)]*))?\))?\>)?\s*(?P<useRE>~~)?(?P<location>[^~].*)?")
    FILEDECL_STRUCTURE = "  Structure is '<id?(type?:intent?)> location?'"
    MAP_RE = re.compile(r"(?P<source>(?:\s|.)*)(?:\s*)-\((?P<mapping>(?:1|\*)-(?:1|\*))\)->(?:\s*)(?P<result>(?:\s|.)*)")
    MAP_STRUCTURE = "  Structure is 'source, source, ... -(<mapping>)-> result, result, ...'"
    MAP_EXAMPLE = "  EXAMPLE: <id(tar-bz2:intermediate)> *.tar.bz2 -(1-1)-> <(tar-gz)> ~~\\1.tgz"
    #TODO: Consider allowing extension to other mappings
    #      (myid) -(WackySuperSpecialMapping)-> (stuff)
    #    - require a change in the re
    #    - require a mechanism to expand the table
    #    - require a subclass to FileManager and a way to instantiate
    #      the subclass, or "monkeypatching" (blech)
    MAPPING_DISPATCH_TABLE = {
        '1-1' : 'mapFilesOneToOne',
        '*-1' : 'mapFilesManyToOne',
        '1-*' : 'mapFilesOneToMany',
        '*-*' : 'mapFilesManyToMany' }
    def __init__(self, parents=[]):
        #TODO: Consider throwing exceptions instead erroring on
        #      Parse failures - would yield a way to communicate
        #      where the parsing blew up.
        self.lock = FileManager.FILE_MANAGER_LOCK
        self.index = {}
        self.log = None #TODO: Should be a good default logger
        self.working = None
        self.metadata = None
        self.env = None
        self.results = None
        FileManager.initializeIndex(self.index)
        if parents is not None and len(parents) > 0:
            self.log = parents[0].log
            self.results = parents[0].results
            self.working = parents[0].working
            self.metadata = parents[0].metadata
            self.env = parents[0].env
        self.parents = parents

        self.records = []

    def __repr__(self, offset=0, terse=False):
        self.lock.acquire()
        try:
            space = ' ' * offset
            result = [
                "%s++++++++++++++++++++++++++++++++++++++++++++" % space,
                "%s<%s Instance: %s>" % (
                    space,
                    self.__class__.__name__,
                    hex(id(self))),
                "%sTracking Table:" %space]
            for axis in FileManager.AXES:
                result.append(" %s========== %s ==========" % (space, axis))
                for key, value in self.index[axis].items():
                    result.append("  %s~~~~~~ %s ~~~~~~" % (space, key))
                    for instance in value:
                        if not terse:
                            result.append("  %s%s" % (space, instance.__repr__(offset=offset+2, terse=True)))
            result.append("%s++++++++++++++++++++++++++++++++++++++++++++" % space)
            result.append("")
        finally:
            self.lock.release()
        return '\n'.join(result)

    def __str__(self, offset=0, terse=False):
        return self.__repr__(offset, terse)

    def _dispatchMapper(self, mappingSpec, fromSpecs, toSpecs, result):
        return getattr(
            self,
            FileManager.MAPPING_DISPATCH_TABLE[mappingSpec])(
                fromSpecs,
                toSpecs,
                result)

    @staticmethod
    def initializeIndex(index):
        for axis in FileManager.AXES:
            index[axis] = {}

    @staticmethod
    def fixupLocationWithBase(basepath, location, specdict):
        if location is None or len(location) == 0:
            if 'location' in specdict:
                del specdict['location']
            if 'relLocation' in specdict:
                del specdict['relLocation']
            return
        if location[0] == '/' or location.startswith('{~~path~~}') \
                              or location.startswith('[~~path~~]'):
            relpath = os.path.relpath(location, basepath)
            if relpath.startswith('..'):
                relpath = location
            specdict['location'] = location
            specdict['relLocation'] = relpath
        elif len(location) > 1 and location[0] == '.' and location[1] == '/':
            specdict['relLocation'] = location
            specdict['location'] = os.path.abspath(location)
        else:
            #print "Third case: rel: %s, loc: %s" % (location, basepath)
            specdict['relLocation'] = location
            relpath = os.path.relpath(location, basepath)
            if not relpath.startswith('..'):
                location = relpath
            specdict['location'] = os.path.join(
                basepath,
                location )

    @staticmethod
    def fixupLocationWithoutBase(location, specdict):
        if location is None or len(location) == 0:
            if 'location' in specdict:
                del specdict['location']
            if 'relLocation' in specdict:
                del specdict['relLocation']
            return
        if location[0] == '/' or location.startswith('{~~path~~}') \
                              or location.startswith('[~~path~~]'):
            if 'relLocation' in specdict:
                del specdict['relLocation']
            specdict['location'] = location
        else:
            if 'location' in specdict:
                del specdict['location']
            specdict['relLocation'] = location

    @staticmethod
    def fixupEmptySpecEntries(specdict):
        wipeAxes = []
        for axis, value in specdict.items():
            if value is None or len(value) == 0:
                wipeAxes.append(axis)
        for axis in wipeAxes:
            del specdict[axis]

    @staticmethod
    def countedJoin(currentstar, parts, replacetext):
        """replacetext is required to have %d"""
        if len(parts) == 0:
            return (currentstar, [])
        result = []
        for i, part in enumerate(parts[:-1]):
            result.append(re.escape(part) + (replacetext % (i + currentstar)))
        else:
            result.append(parts[-1])
        return (currentstar + len(parts) - 1, ''.join(result))

    @staticmethod
    def translateStarsToSourceRegex(s):
        path, filename = os.path.split(s)
        filepart, extpart = os.path.splitext(filename)
        extpart = extpart.lstrip('.')

        starcount = 1
        replaceString = '(?P<star%d>[^/]*)'
        starSplitRE = r'^\*|[^\\]\*'

        if len(path) != 0:
            pathparts = re.split(starSplitRE,path)
            #pathparts = path.split('*')
            starcount, unstarredPath = FileManager.countedJoin(
                starcount,
                pathparts,
                replaceString)
        else:
            unstarredPath = None
        #filepartParts = filepart.split('*')
        filepartParts = re.split(starSplitRE,filepart)
        starcount, unstarredFile = FileManager.countedJoin(
            starcount,
            filepartParts,
            replaceString)
        if len(extpart) != 0:
            #extpartParts = extpart.split('*')
            extpartParts = re.split(starSplitRE,extpart)
            starcount, unstarredExt = FileManager.countedJoin(
                starcount,
                extpartParts,
                replaceString)
        else:
            unstarredExt = None
        if unstarredPath is not None:
            pathpart = r'(?P<path>%s)/' % unstarredPath
        else:
            pathpart = ''
        filepart = r'(?P<file>(?P<filename>%s)' % unstarredFile
        if unstarredExt is not None:
            extpart = r'[.](?P<ext>%s)' % unstarredExt
        else:
            extpart = ''
        return '%s%s%s)' % (
            pathpart,
            filepart,
            extpart )

    @staticmethod
    def translateStarsToResultRegex(s):
        starcount = 1
        sparts = s.split('*')
        starcount, result = FileManager.countedJoin(
            starcount,
            sparts,
            '\g<star%d>' )
        keywords = FileManager.FILE_AXES
        for key in keywords:
            result = result.replace('{~~', '[~~')
            result = result.replace('~~}', '~~]')
            result = result.replace('[~~%s~~]' % key, '\g<%s>' % key)
        return result

    @staticmethod
    def findDiskPrunedPossibleMatchingRegexFiles(pathparts, curpath = '/'):
        #This will pruposely return more than what actually matches pathparts
        #You can't actually break a regex into path parts and sample each
        #Without rewriting regex parsing and grocking in a way that is
        #Sensitive to the way a directory structure works.
        if len(pathparts) == 0:
            return []
        if len(pathparts[0]) == len(re.escape(pathparts[0])):
            newpath = os.path.join(
                curpath,
                pathparts[0] )
            if os.path.exists(newpath):
                return FileManager.findDiskPrunedPossibleMatchingRegexFiles(
                    pathparts[1:],
                    newpath)
            else:
                return []
        else:
            result = []
            for base, dirs, files in os.walk(curpath):
                for name in files:
                    result.append(os.path.join(
                        base,
                        name ))
                for name in dirs:
                    result.append(os.path.join(
                        base,
                        name ))
            return result

    @staticmethod
    def findDiskFilesMatchingRegex(repath):
        pathparts = repath.split('/')
        if len(pathparts) == 0:
            return []
        assert(len(pathparts[0])) == 0
        pathparts = pathparts[1:]
        candidates = FileManager.findDiskPrunedPossibleMatchingRegexFiles(
            pathparts )
        repathCompiled = re.compile(repath)
        return [ f for f in candidates if repathCompiled.match(f) ]

    @staticmethod
    def findDiskFilesMatchingStarred(path):
        return glob.glob(path)

    @staticmethod
    def fileInstanceCorrectTracking(deleting, validate):
        if deleting:
            FileInstanceClass = DeletedFileInstance
        else:
            FileInstanceClass = FileInstance
        if not validate:
            FileInstanceClass = NonValidatedFileInstance
        return FileInstanceClass

    def parseFileReferenceList(self, references):
        sourcesParsed = []
        for reference in references:
            match = FileManager.FILEDECL_RE.match(reference)
            if match is None:
                self.log.error("'%s' is not properly formatted", reference)
                self.log.error(FileManager.FILEDECL_STRUCTURE)
                self.log.error('  Got: %s', source)
            spec = match.groupdict()
            if 'location' in spec:
                FileManager.fixupLocationWithoutBase(
                    spec['location'],
                    spec)
            FileManager.fixupEmptySpecEntries(spec)
            sourcesParsed.append(FileSpec(**spec))
        return sourcesParsed

    def parseFileResultsList(self, references):
        resultsParsed = []
        for resultItem in references:
            match = FileManager.FILEDECL_RE.match(resultItem)
            if match is None:
                self.log.error("A result in the file map is not properly formatted")
                self.log.error(FileManager.FILEDECL_STRUCTURE)
                self.log.error("  Got: %s", resultItem)
                continue
            spec = match.groupdict()
            if 'location' in spec:
                FileManager.fixupLocationWithBase(
                    self.results,
                    spec['location'],
                    spec )
            FileManager.fixupEmptySpecEntries(spec)
            resultsParsed.append(FileSpec(**spec))
        return resultsParsed

    def resolveFileMappings(self, references, allowUntracked=False):
        #references is a python list of file specs from a csmakefile
        #  call CsmakeModule's _parseCommaAndNewlineList to get from a
        #  csmakefile list of files to a python list
        references = self.parseFileReferenceList(references)
        result = []
        for reference in references:
            instances = self.findInstances(reference)
            if len(instances) == 0:
                self.log.debug("File %s not found in tracking", reference)
                if allowUntracked:
                    index = reference.index
                    if 'location' in index:
                        location = index['location']
                    else:
                        location = index['relLocation']
                    FileManager.fixupLocationWithBase(
                        self.env.env['WORKING'],
                        index['relLocation'],
                        index )
                    newInstance = FileInstance(**index)
                    result.append(newInstance)
            result.extend(instances)
        return result


    def absorbMappings(self, mappingResult, deleting=False, validate=True):
        FileInstanceClass = FileManager.fileInstanceCorrectTracking(deleting, validate)
        for frominstances, tospecs in mappingResult.itermappings():
            newid = []
            fromrecords = []
            for frominstance in frominstances:
                newid.append(frominstance.recordId())
                record = frominstance.getRecord()
                fromrecords.append(record)

            absorbtion = []

            for tospec in tospecs:
                containingRecord = None
                if 'id' not in tospec:
                    tospec['id'] = '+'.join(newid)
                if tospec['id'] in newid:
                    containingRecord = fromrecords[newid.index(tospec['id'])]
                    instance = FileInstanceClass(**tospec)
                    containingRecord.addAnotherInstance(instance.index, instance)
                if containingRecord is None:
                    containingRecord = FileRecord(fromrecords, deleting, validate, **tospec)
                    instance = containingRecord.getSourceInstance()
                absorbtion.append((containingRecord, instance))
                self.log.devdebug("Adding mapping: %s", str(tospec))
            for record in fromrecords:
                record.absorbNewFiles(absorbtion)

    def parseFileMap(self, statement):
        result = FileMapping()
        statement = ' '.join(statement.split('\n'))
        mappingStatements = statement.split('&&')
        for mappingStatement in mappingStatements:
            mappingStatement = mappingStatement.strip()
            match = FileManager.MAP_RE.match(mappingStatement)
            if match is None:
                self.log.error("File map is not properly formatted")
                self.log.error(FileManager.MAP_STRUCTURE)
                self.log.error("  Got: %s", mappingStatement)
                return None
            mapdict = match.groupdict()
            for key, value in mapdict.items():
                if value is None or len(value) == 0:
                    self.log.error("File map is missing a part (%s)", key)
                    self.log.error(FileManager.MAP_STRUCTURE)
                    self.log.error("  Got: %s", mappingStatement)
                    return None

            sourcesList = [x.strip() for x in mapdict['source'].split(',')]
            resultsList = [x.strip() for x in mapdict['result'].split(',')]

            sourcesParsed = self.parseFileReferenceList(sourcesList)
            resultsParsed = self.parseFileResultsList(resultsList)

            mapping = mapdict['mapping']
            result.addMappingSpecification(mapping)
            self._dispatchMapper(
                mapping,
                sourcesParsed,
                resultsParsed,
                result)
        return result

    def findRecordsOnAxis(self, axis, value):
        try:
            return self.index[axis][value]
        except:
            return []

    def findRecordsOnREAxis(self, axis, revalue):
        locked = False
        try:
            self.lock.acquire()
            locked = True
            test = re.compile(revalue)
            return [value \
               for key, values in self.index[axis].items() \
               if test.search(key) \
                   for value in values ]
        except re.error:
            raise
        except Exception:
            return []
        finally:
            if locked:
                self.lock.release()

    def findRecordsOnLocationSpec(self, spec):
        if 'location' not in spec.index:
            return None
        location = spec.getSourceLocationRE()
        return self.findRecordsOnREAxis('location', location)

    def findRecordsOnRelLocationSpec(self, spec):
        if 'relLocation' not in spec.index:
            return None
        location = spec.getSourceRelLocationRE()
        self.log.devdebug("Rel location to try: '%s'", location)
        return self.findRecordsOnREAxis('relLocation', location)

    def findInstances(self, spec):
        records = self.findRecords(spec)
        result = []
        for record in records:
            result.extend(record.findInstances(spec))
        return list(set(result))

    def _standardAxesIndexLookup(self, spec):
        resultSet = None
        locked = False
        try:
            self.lock.acquire()
            locked = True
            for axis, value in spec.index.items():
                if axis in FileManager.NON_AXES:
                    continue
                if axis == 'location':
                    #Location requires some special handling because
                    #  users are allowed to use re's and * matching.
                    #TODO: Should we wait and just weed out the
                    #      locations from the remaining matches
                    #      instead of digging through everything?
                    records = self.findRecordsOnLocationSpec(spec)
                elif axis == 'relLocation':
                    records = self.findRecordsOnRelLocationSpec(spec)
                else:
                    records = self.findRecordsOnAxis(axis, value)
                if records is None or len(records) == 0:
                    return []
                current = set(records)
                if resultSet is None:
                    resultSet = current
                else:
                    resultSet &= current
            if resultSet is None or len(resultSet) == 0:
                return []
            else:
                return list(resultSet)
        finally:
            if locked:
                self.lock.release()

    def findRecords(self, spec):
        resultSet = None
        locked = False
        try:
            self.lock.acquire()
            locked = True
            if 'id' in spec.index:
                #If the id is called out in the spec, this takes
                #Precedence in the search for the record.  I.e., we
                #Go directly to that record and let it search for the
                #remaining axes.
                if spec.index['id'] in self.index['id']:
                    return list(set(self.index['id'][spec.index['id']]))
                else:
                    return []
        finally:
            if locked:
                self.lock.release()
        return self._standardAxesIndexLookup(spec)

    def _getFileDeclarationList(self, statement):
        flatstatement = ''.join(',<'.join(statement.strip().split('<'))[1:].split('\n'))
        declarations =  [ f.strip() for f in flatstatement.split(',') if len(f.strip()) > 0] 
        return declarations

    def parseFileDeclarationForIndexes(self, statement):
        declarations = self._getFileDeclarationList(statement)
        indexes = []
        for declaration in declarations:
            indexes.append(self._getFileDeclarationIndex(declaration.strip()))
        return indexes

    def parseFileDeclaration(self, statement):
        indexes = self.parseFileDeclarationForIndexes(statement)
        return self.addFileIndexes(indexes)

    def _getFileDeclarationIndex(self, parseableFileEntry):
        filematch = FileManager.FILEDECL_RE.match(parseableFileEntry)
        if filematch is None:
            self.log.error(
                "Parsing of file declaration failed: %s",
                parsableFileEntry )
            raise ValueError("File declaration did not parse")
        filematch = filematch.groupdict()
        return filematch

    def addFileIndexes(self, filematches, defaultPath=None, deleting=False, validate=True):
        if defaultPath is None:
            defaultPath = self.working
        addedResults = []
        for filematch in filematches:

            if 'location' not in filematch or not filematch['location']:
                self.log.error("File declarations require a location, but none was provided")
            FileManager.fixupLocationWithBase(
                defaultPath,
                filematch['location'],
                filematch )
            newPaths = []
            if 'useRE' in filematch and filematch['useRE']:
                newPaths = FileManager.findDiskFilesMatchingRegex(
                    filematch['location'] )
            else:
                newPaths = FileManager.findDiskFilesMatchingStarred(
                    filematch['location'] )

            if len(newPaths) == 0 and not deleting and validate:
                self.log.error("No files were found for specification: %s",
                    str(filematch) )
                #raise ValueError(
                #    "No files were found for specification: %s" % str(filematch))
            if len(newPaths) > 0 and deleting and validate:
                self.log.error("Files specified were found on cleaning: %s",
                    str(filematch) )
                raise ValueError(
                    "Files were found that were supposed to be cleaned" )

            ftemplate = filematch
            records = []
            result = []
            for new in newPaths:
                FileManager.fixupLocationWithBase(
                    defaultPath,
                    new,
                    ftemplate )
                self.log.devdebug("Adding file record: %s", str(ftemplate))
                record = FileRecord([self], deleting, validate, **ftemplate)
                result.append(record.getSourceInstance())
                records.append(record)
            self.addRecords(records)
            addedResults.extend(result)
        return addedResults

    def addFileDeclaration(self, parseableFileEntry):
        """Call this to add a file declaration from a specification"""
        filematch = self._getFileDeclarationIndex(parseableFileEntry)
        return self.addFileIndexes([filematch])

    def addIndicies(self, indicies, item):
        locked = False
        try:
            self.lock.acquire()
            locked = True
            for axis, value in indicies.items():
                if axis not in self.index:
                    self.index[axis] = {}
                if value not in self.index[axis]:
                    self.index[axis][value] = []
                self.index[axis][value].append(item)
        finally:
            if locked:
                self.lock.release()

    def addRecords(self, records):
        if len(records) > 0:
            self.records.append(records)
            for parent in self.parents:
                parent.addRecords(records)

    def mapFilesManyToMany(self, fromSpecs, toSpecs, result):
        #Record the mapping of a file from one set of instances
        #to another instance
        #The result is a file manager with just the results requested
        #The operation performed will be that all the instances
        #  will together derive all the newInstances.
        #  since this is a many to many mapping, every new instance
        #  will be a part of every record of the given instances
        #   - if the new instances specify their own ids, they
        #     will also be given new records
        #  Example: a.c, b.c, c.c, d.c -(*-*)-> mylib.so, mylib.lib
        #  If no new type is specified, the new type will be a tuple
        #   of all the source types
        #  If no new intent is specified, the new intent will be a string
        #  of unique intents joined with a '+' in no particular order
        #  TODO: This all above needs to be implemented....
        #        That would apply for the *-1 mapping too.
        #All new results will be recorded in the manager
        #upon successful completion of the step
        # - to support automated parallelization, you could put
        #   some kind of "future" instance entry in the manager that
        #   would resolve and unblock when the instance resolved
        instanceList = []
        for spec in fromSpecs:
            instanceList.extend(self.findInstances(spec))
        if len(instanceList) == 0:
            return
        froms = instanceList
        tos = [spec.index for spec in toSpecs]
        self._fromManyMapSubstitutions(froms, toSpecs)
        result.addMapping(froms,tos)
        self.log.devdebug("Calculated mapping: %s -(*-*)-> %s", str(froms), str(tos))

    def _deriveResultInstanceSpec(self, instance, fromSpec, toSpec):
        newinstanceSpec = {}
        for axis in set(instance.index.keys()) \
                    | set(fromSpec.index.keys()) \
                    | set(toSpec.index.keys()):
            if axis not in toSpec.index:
                if axis not in fromSpec.index:
                    newinstanceSpec[axis] = instance.index[axis]
                else:
                    newinstanceSpec[axis] = fromSpec.index[axis]
            else:
                newinstanceSpec[axis] = toSpec.index[axis]
        actualLocation = self._deriveResultFileFromSource(
            instance, fromSpec, toSpec )
        if actualLocation is not None:
            FileManager.fixupLocationWithBase(
                self.results,
                actualLocation,
                newinstanceSpec )
        self.log.devdebug("newinstanceSpec: %s", str(newinstanceSpec))
        for axis, value in newinstanceSpec.items():
            if value is None:
                continue
            #print axis, value, newinstanceSpec
            newinstanceSpec['location'] = re.sub(r'\[~~%s~~\]' % axis, str(value), newinstanceSpec['location'])
            toSpec.index['location'] = newinstanceSpec['location']
            newinstanceSpec['relLocation'] = re.sub(r'\[~~%s~~\]' % axis, str(value), newinstanceSpec['relLocation'])
            toSpec.index['relLocation'] = newinstanceSpec['relLocation']
        self.log.devdebug("newinstancespec: ", str(newinstanceSpec))
        return newinstanceSpec

    def _determineMatchingLocationFromSource(self, instance, fromSpec, toSpec):
        sourcere = fromSpec.getSourceLocationRE()
        instanceAxis = 'location'
        resultre = toSpec.getResultLocationRE()
        if sourcere is None:
            sourcere = fromSpec.getSourceRelLocationRE()
            instanceAxis = 'relLocation'
            resultre = toSpec.getResultRelLocationRE()
        if sourcere is None:
            sourcere = instance.getSourceRelLocationRE()
            instanceAxis = 'relLocation'
            resultre = toSpec.getResultRelLocationRE()
        self.log.devdebug("Matching: %s", sourcere)
        return (sourcere, resultre, instanceAxis)

    def _deriveResultFileFromSource(self, instance, fromSpec, toSpec):
        sourcere, resultre, instanceAxis = self._determineMatchingLocationFromSource(instance, fromSpec, toSpec)
        matchTarget = instance.index[instanceAxis]
        if type(matchTarget) is dict:
            return None
        matcher = re.match(sourcere, matchTarget)
        if matcher is None:
            self.log.error(
                "Error: Requested location didn't match the spec")
            self.log.error(
                "From: %s   Location: %s",
                sourcere,
                instance.index[instanceAxis] )
            self.log.debug(
                "   --params: instance: %s", str(instance))
            self.log.debug(
                "             fromSpec: %s", str(fromSpec))
            self.log.debug(
                "             toSpec:   %s", str(toSpec))
            return None
        try:
            return matcher.expand(resultre)
        except IndexError as ie:
            self.log.devdebug(
                "toSpec wanted: %s", str(ie))
            sourcere = instance.getSourceLocationRE()
            instanceAxis = 'location'
            resultre = toSpec.getResultLocationRE()
            matcher = re.match(sourcere, instance.index[instanceAxis])
            if matcher is None:
                self.log.error(
                    "Error: chosen location didn't match the spec")
                self.log.error(
                    "From: %s   Location: %s",
                    sourcere,
                    instance.index['location'] )
                return None
            try:
                return matcher.expand(resultre)
            except Exception:
                self.log.exception(
                    "From: %s  To: %s  Instance: %s",
                    sourcere,
                    resultre,
                    instance.index['location'] )
        except Exception:
            self.log.exception(
                "From: %s  To: %s  Instance: %s",
                sourcere,
                resultre,
                instance.index['location'] )
        return None

    def mapFilesOneToOne(self, fromSpecs, toSpecs, result):
        #Using ANT's glob and regexp mapper matching syntax - almost
        #our mapping will break it down into 3 parts path, file, ext
        #and using * in multiple locations will attempt to match
        #* for *
        #location=%(TARGET)s/*.*
        #  will specify a new path
        #location=*/blah*.*.new
        #  will specify a new extension 'new' and a new name blah (with old name appended and 'new' appended on to the old extension)
        #  NOTE: an a.b.c.d file will be file == a.b.c, ext == d
        #location=*/path-thing/b.a.d.c:
        #  Need to match wildcards  e.g., a/b/*/d -()->
        #  Proposed filemap syntax
        #    <id(type:intent)> location, ... -(mapping)-> <id(type:intent)> location
        #  Regex filemap:
        #    <id(type:intent)> ~~location, ... -(mapping)-> <id(type:intent)> location
        #  <man(groff:man-source)> ~~%(WORKING)s/docs/(.*)\.groff
        #     -(1-1)-> <man(gzip:man-page)> ~~%(TARGET)s/docs/\1
        #  re->re match with backtracing
        #  <man(groff:man-source)> ~~%(WORKING)s/docs/(.*)\.groff
        #     -(1-1)-> <man(gzip:man-page)> %(TARGET)s/docs/*
        #  re->
        #  E.g., id mapping to new file type
        #  <manpages> *.*.* -(1-1)-> <manpages(gzip:man-page)> *.*
        #     - takes anything id'ed as manpages and maps
        #       it to manpages(gzip:man-page) type and intent
        #  <(python:source)> %(WORKING)s/pythonpath/*.*.py -(1-1)-> <(python:object)>%(TARGET)/*.*.pyo
        #  <(:source)> -(*-1)-> <mylib(elf-static-link:library)>
        #  <(:source)> -(*-1)-> <mylib(elf-static-link:library)>
        for spec in fromSpecs:
            instances = self.findInstances(spec)
            for instance in instances:
                if isinstance(instance, FileRecord):
                    continue
                for toSpec in toSpecs:
                    newinstanceSpec = self._deriveResultInstanceSpec(
                        instance,
                        spec,
                        toSpec )
                    self.log.devdebug("Calculated Mapping: %s -(1-1)-> %s", str(instance), str(newinstanceSpec))
                    result.addMapping([instance], [newinstanceSpec])

    def mapFilesOneToMany(self, fromSpecs, toSpecs, result):
        newinstanceSpecs = []
        for spec in fromSpecs:
            instances = self.findInstances(spec)
            for instance in instances:
                newinstanceSpecs = []
                for toSpec in toSpecs:
                    newinstanceSpecs.append(
                        self._deriveResultInstanceSpec(
                            instance,
                            spec,
                            toSpec ) )
                result.addMapping([instance], newinstanceSpecs)
                self.log.devdebug("Calculated Mapping: %s -(1-*)-> %s", str(instance), str(newinstanceSpecs))

    def _fromManyMapSubstitutions(self, froms, tos):
        specCollection = {}
        thunkTo = tos[0]
        for afrom in froms:
            sourcere, _, axis = self._determineMatchingLocationFromSource(afrom, afrom, thunkTo)
            matcher = re.match(sourcere, afrom.index[axis])
            if matcher is not None:
                index = { k: v for k, v in matcher.groupdict().items() if v is not None }
            else:
                index = {}
            index.update(afrom.index)
            for key, value in index.items():
                if key not in specCollection:
                    specCollection[key] = value
                if specCollection[key] != value:
                    specCollection[key] = [value, specCollection[key]]
        for ato in tos:
            for key, value in ato.index.items():
                if '[~~' in value:
                    continue
                if key not in specCollection:
                    specCollection[key] = value
                if specCollection[key] != value or type(value) is list:
                    specCollection[key] = value
                else:
                    specCollection[key] = {'values': [value, specCollection[key]]}
        for ato in tos:
            for locKey in ['location', 'relLocation']:
                if locKey in ato.index:
                    if '{~~' in ato.index[locKey]:
                        self.log.error("Depricated substitution syntax {~~<key>~~} used and not supported: %s", str(ato))
                        raise ValueError("Depricated substitution")
                    for key, value in specCollection.items():
                        if '[~~%s~~]' % key in ato.index[locKey]:
                            if type(value) is list or type(value) is dict:
                                self.log.error("Indeterminate substitution (%s): %s", key, str(ato))
                                raise ValueError("Indeterminate substitution")
                            ato.index[locKey] = re.sub(r'\[~~%s~~\]' % key, str(value), ato.index[locKey])
                    if '[~~' in ato.index[locKey]:
                        self.log.error("Unresolved substitution: %s", str(ato))
                        raise ValueError("Unresolved substitution")

    def mapFilesManyToOne(self, fromSpecs, toSpecs, result):
        instanceList = []
        for spec in fromSpecs:
            instanceList.extend(self.findInstances(spec))
        if len(instanceList) == 0:
            return
        
        for toSpec in toSpecs:
            #TODO: What deriviation should there be?
            #      IDs?  There needs to be some way to
            #      note that the derived files came from
            #      all the specified IDs....hmmm
            #      could be an exercise for when we take the
            #      result back in
            self._fromManyMapSubstitutions(instanceList, [toSpec])
            result.addMapping(instanceList, [toSpec.index])
            self.log.devdebug("Calculated Mapping: %s -(*-1)-> %s", str(instanceList), str(toSpec.index))

class MetadataFileTracker(FileManager):
    #Metadata is namespace
    def __init__(self, metadata, log, env):
        FileManager.__init__(self)
        self.log = log
        self.metadata = metadata
        self.env = env
        self.working = env.env['WORKING']
        self.results = env.env['RESULTS']

class FileRecord(FileManager, IndexedFileEntry):
    def __init__(self, parents, deleting=False, validate=True, **instanceInfo):
        IndexedFileEntry.__init__(self)
        FileManager.__init__(self, parents)

        FileInstanceClass = FileManager.fileInstanceCorrectTracking(deleting, validate)
        instance = FileInstanceClass(**instanceInfo)
        self.recordid = instanceInfo['id']
        instance.setRecord(self)
        self.sourceInstance = instance
        self.addInstanceIndicies(instanceInfo, instance)
        instance.setPrecedence(1, self)
        self.records.append(instance)
        for parent in parents:
            parent.addIndicies(instanceInfo, self)

    def __repr__(self, offset=0, terse=False):
        result = ["Record Id: %s" % self.recordid,
            "Source instance: %s" % self.sourceInstance,
            "Current record: %s" % self.records[-1] ]
        return '\n'.join(result) + FileManager.__repr__(self, offset+2, terse)

    def __str__(self, offset=0, terse=False):
        return self.__repr__(offset, terse)

    def setRecord(self, record):
        self.parent = record

    def getRecord(self):
        return self.parent

    def addAnotherInstance(self, instanceInfo, instance):
        instance.setRecord(self)
        self.addInstanceIndicies(instanceInfo, instance)

    def addInstanceIndicies(self, instanceInfo, instance):
        FileManager.addIndicies(self, instanceInfo, instance)

    def addIndicies(self, instanceInfo, item):
        locked = False
        try:
            self.lock.acquire()
            locked = True
            FileManager.addIndicies(self, instanceInfo, item)
            self.index['id'][instanceInfo['id']].append(item)
            for parent in self.parents:
                parent.addIndicies(instanceInfo, item)
        finally:
            if locked:
                self.lock.release()

    def addRecords(self, records):
        FileManager.addRecords(self, records)
        for record in records:
            record.setPrecedence(len(self.records), self)

    def absorbNewFiles(self, files):
        recordset = []
        for record, instance in files:
            if self is record:
                for parent in self.parents:
                    parent.addIndicies(instance.index, self)
                recordset.append(instance)
            else:
                self.addIndicies(instance.index, record)
                recordset.append(record)
        self.addRecords(recordset)

    def getSourceInstance(self):
        return self.sourceInstance

    def findInstances(self, spec):
        #NOTE: This query doesn't need to be locked
        #      If things change in mid-flight to make this invalid, there's
        #      a problem with the build, the steps causing the issue
        #      should not be concurrent
        resultSet = self._standardAxesIndexLookup(spec)
        totalAxes = 0
        specAxes = list(spec.index.keys())
        for key in specAxes:
            if key in FileManager.AXES:
                totalAxes = totalAxes + 1
        if totalAxes != 1 or specAxes[0] != 'id':
            return resultSet
        for result in resultSet:
            result.setCurrentPrecedenceKey(self)
        resultSet.sort()
        for result in resultSet:
            result.finishedCurrentPrecedenceKey()
        instances = []
        lockedPrecedent = None
        for result in reversed(resultSet):
            if lockedPrecedent is not None:
                if result.getPrecedence(self) != lockedPrecedent:
                    return instances
            current = result.findInstances(spec)
            if current is not None and len(current) > 0:
                lockedPrecedent = result.getPrecedence(self)
                instances.extend(current)
        return instances

    def getSourceLocationRE(self):
        return self.records[-1].getSourceLocationRE()

    def getSourceRelLocationRE(self):
        return self.records[-1].getSourceRelLocationRE()

    def getResultLocationRE(self):
        return self.records[-1].getResultLocationRE()

    def getResultRelLocationRE(self):
        return self.records[-1].getResultRelLocationRE()
